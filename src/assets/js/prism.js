/* PrismJS 1.19.0
https://prismjs.com/download.html#themes=prism-okaidia&languages=markup+css+clike+javascript+c+cpp+django+git+go+java+jq+json+markdown+markup-templating+python */
var _self = typeof window !== 'undefined' ? window : typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope ? self : {}; var Prism = (function (u) { var c = /\blang(?:uage)?-([\w-]+)\b/i; var n = 0; var C = { manual: u.Prism && u.Prism.manual, disableWorkerMessageHandler: u.Prism && u.Prism.disableWorkerMessageHandler, util: { encode: function e (n) { return n instanceof _ ? new _(n.type, e(n.content), n.alias) : Array.isArray(n) ? n.map(e) : n.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/\u00a0/g, ' ') }, type: function (e) { return Object.prototype.toString.call(e).slice(8, -1) }, objId: function (e) { return e.__id || Object.defineProperty(e, '__id', { value: ++n }), e.__id }, clone: function t (e, r) { var a; var n; var l = C.util.type(e); switch (r = r || {}, l) { case 'Object':if (n = C.util.objId(e), r[n]) return r[n]; for (var i in a = {}, r[n] = a, e)e.hasOwnProperty(i) && (a[i] = t(e[i], r)); return a; case 'Array':return n = C.util.objId(e), r[n] ? r[n] : (a = [], r[n] = a, e.forEach(function (e, n) { a[n] = t(e, r) }), a); default:return e } }, getLanguage: function (e) { for (;e && !c.test(e.className);)e = e.parentElement; return e ? (e.className.match(c) || [, 'none'])[1].toLowerCase() : 'none' }, currentScript: function () { if (typeof document === 'undefined') return null; if ('currentScript' in document) return document.currentScript; try { throw new Error() } catch (e) { var n = (/at [^(\r\n]*\((.*):.+:.+\)$/i.exec(e.stack) || [])[1]; if (n) { var t = document.getElementsByTagName('script'); for (var r in t) if (t[r].src == n) return t[r] } return null } } }, languages: { extend: function (e, n) { var t = C.util.clone(C.languages[e]); for (var r in n)t[r] = n[r]; return t }, insertBefore: function (t, e, n, r) { var a = (r = r || C.languages)[t]; var l = {}; for (var i in a) if (a.hasOwnProperty(i)) { if (i == e) for (var o in n)n.hasOwnProperty(o) && (l[o] = n[o]); n.hasOwnProperty(i) || (l[i] = a[i]) } var s = r[t]; return r[t] = l, C.languages.DFS(C.languages, function (e, n) { n === s && e != t && (this[e] = l) }), l }, DFS: function e (n, t, r, a) { a = a || {}; var l = C.util.objId; for (var i in n) if (n.hasOwnProperty(i)) { t.call(n, i, n[i], r || i); var o = n[i]; var s = C.util.type(o); s !== 'Object' || a[l(o)] ? s !== 'Array' || a[l(o)] || (a[l(o)] = !0, e(o, t, i, a)) : (a[l(o)] = !0, e(o, t, null, a)) } } }, plugins: {}, highlightAll: function (e, n) { C.highlightAllUnder(document, e, n) }, highlightAllUnder: function (e, n, t) { var r = { callback: t, container: e, selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code' }; C.hooks.run('before-highlightall', r), r.elements = Array.prototype.slice.apply(r.container.querySelectorAll(r.selector)), C.hooks.run('before-all-elements-highlight', r); for (var a, l = 0; a = r.elements[l++];)C.highlightElement(a, !0 === n, r.callback) }, highlightElement: function (e, n, t) { var r = C.util.getLanguage(e); var a = C.languages[r]; e.className = e.className.replace(c, '').replace(/\s+/g, ' ') + ' language-' + r; var l = e.parentNode; l && l.nodeName.toLowerCase() === 'pre' && (l.className = l.className.replace(c, '').replace(/\s+/g, ' ') + ' language-' + r); var i = { element: e, language: r, grammar: a, code: e.textContent }; function o (e) { i.highlightedCode = e, C.hooks.run('before-insert', i), i.element.innerHTML = i.highlightedCode, C.hooks.run('after-highlight', i), C.hooks.run('complete', i), t && t.call(i.element) } if (C.hooks.run('before-sanity-check', i), !i.code) return C.hooks.run('complete', i), void (t && t.call(i.element)); if (C.hooks.run('before-highlight', i), i.grammar) if (n && u.Worker) { var s = new Worker(C.filename); s.onmessage = function (e) { o(e.data) }, s.postMessage(JSON.stringify({ language: i.language, code: i.code, immediateClose: !0 })) } else o(C.highlight(i.code, i.grammar, i.language)); else o(C.util.encode(i.code)) }, highlight: function (e, n, t) { var r = { code: e, grammar: n, language: t }; return C.hooks.run('before-tokenize', r), r.tokens = C.tokenize(r.code, r.grammar), C.hooks.run('after-tokenize', r), _.stringify(C.util.encode(r.tokens), r.language) }, tokenize: function (e, n) { var t = n.rest; if (t) { for (var r in t)n[r] = t[r]; delete n.rest } var a = new l(); return M(a, a.head, e), (function e (n, t, r, a, l, i, o) { for (var s in r) if (r.hasOwnProperty(s) && r[s]) { var u = r[s]; u = Array.isArray(u) ? u : [u]; for (var c = 0; c < u.length; ++c) { if (o && o == s + ',' + c) return; var g = u[c]; var f = g.inside; var h = !!g.lookbehind; var d = !!g.greedy; var v = 0; var p = g.alias; if (d && !g.pattern.global) { var m = g.pattern.toString().match(/[imsuy]*$/)[0]; g.pattern = RegExp(g.pattern.source, m + 'g') }g = g.pattern || g; for (var y = a.next, k = l; y !== t.tail; k += y.value.length, y = y.next) { var b = y.value; if (t.length > n.length) return; if (!(b instanceof _)) { var x = 1; if (d && y != t.tail.prev) { g.lastIndex = k; var w = g.exec(n); if (!w) break; var A = w.index + (h && w[1] ? w[1].length : 0); var P = w.index + w[0].length; var S = k; for (S += y.value.length; S <= A;)y = y.next, S += y.value.length; if (S -= y.value.length, k = S, y.value instanceof _) continue; for (var O = y; O !== t.tail && (S < P || typeof O.value === 'string' && !O.prev.value.greedy); O = O.next)x++, S += O.value.length; x--, b = n.slice(k, S), w.index -= k } else { g.lastIndex = 0; var w = g.exec(b) } if (w) { h && (v = w[1] ? w[1].length : 0); var A = w.index + v; var w = w[0].slice(v); var P = A + w.length; var E = b.slice(0, A); var N = b.slice(P); var j = y.prev; E && (j = M(t, j, E), k += E.length), W(t, j, x); var L = new _(s, f ? C.tokenize(w, f) : w, p, w, d); if (y = M(t, j, L), N && M(t, y, N), x > 1 && e(n, t, r, y.prev, k, !0, s + ',' + c), i) break } else if (i) break } } } } }(e, a, n, a.head, 0)), (function (e) { var n = []; var t = e.head.next; for (;t !== e.tail;)n.push(t.value), t = t.next; return n }(a)) }, hooks: { all: {}, add: function (e, n) { var t = C.hooks.all; t[e] = t[e] || [], t[e].push(n) }, run: function (e, n) { var t = C.hooks.all[e]; if (t && t.length) for (var r, a = 0; r = t[a++];)r(n) } }, Token: _ }; function _ (e, n, t, r, a) { this.type = e, this.content = n, this.alias = t, this.length = 0 | (r || '').length, this.greedy = !!a } function l () { var e = { value: null, prev: null, next: null }; var n = { value: null, prev: e, next: null }; e.next = n, this.head = e, this.tail = n, this.length = 0 } function M (e, n, t) { var r = n.next; var a = { value: t, prev: n, next: r }; return n.next = a, r.prev = a, e.length++, a } function W (e, n, t) { for (var r = n.next, a = 0; a < t && r !== e.tail; a++)r = r.next; (n.next = r).prev = n, e.length -= a } if (u.Prism = C, _.stringify = function n (e, t) { if (typeof e === 'string') return e; if (Array.isArray(e)) { var r = ''; return e.forEach(function (e) { r += n(e, t) }), r } var a = { type: e.type, content: n(e.content, t), tag: 'span', classes: ['token', e.type], attributes: {}, language: t }; var l = e.alias; l && (Array.isArray(l) ? Array.prototype.push.apply(a.classes, l) : a.classes.push(l)), C.hooks.run('wrap', a); var i = ''; for (var o in a.attributes)i += ' ' + o + '="' + (a.attributes[o] || '').replace(/"/g, '&quot;') + '"'; return '<' + a.tag + ' class="' + a.classes.join(' ') + '"' + i + '>' + a.content + '</' + a.tag + '>' }, !u.document) return u.addEventListener && (C.disableWorkerMessageHandler || u.addEventListener('message', function (e) { var n = JSON.parse(e.data); var t = n.language; var r = n.code; var a = n.immediateClose; u.postMessage(C.highlight(r, C.languages[t], t)), a && u.close() }, !1)), C; var e = C.util.currentScript(); function t () { C.manual || C.highlightAll() } if (e && (C.filename = e.src, e.hasAttribute('data-manual') && (C.manual = !0)), !C.manual) { var r = document.readyState; r === 'loading' || r === 'interactive' && e && e.defer ? document.addEventListener('DOMContentLoaded', t) : window.requestAnimationFrame ? window.requestAnimationFrame(t) : window.setTimeout(t, 16) } return C }(_self)); typeof module !== 'undefined' && module.exports && (module.exports = Prism), typeof global !== 'undefined' && (global.Prism = Prism)
Prism.languages.markup = { comment: /<!--[\s\S]*?-->/, prolog: /<\?[\s\S]+?\?>/, doctype: { pattern: /<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:(?!<!--)[^"'\]]|"[^"]*"|'[^']*'|<!--[\s\S]*?-->)*\]\s*)?>/i, greedy: !0 }, cdata: /<!\[CDATA\[[\s\S]*?]]>/i, tag: { pattern: /<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/i, greedy: !0, inside: { tag: { pattern: /^<\/?[^\s>\/]+/i, inside: { punctuation: /^<\/?/, namespace: /^[^\s>\/:]+:/ } }, 'attr-value': { pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/i, inside: { punctuation: [/^=/, { pattern: /^(\s*)["']|["']$/, lookbehind: !0 }] } }, punctuation: /\/?>/, 'attr-name': { pattern: /[^\s>\/]+/, inside: { namespace: /^[^\s>\/:]+:/ } } } }, entity: /&#?[\da-z]{1,8};/i }, Prism.languages.markup.tag.inside['attr-value'].inside.entity = Prism.languages.markup.entity, Prism.hooks.add('wrap', function (a) { a.type === 'entity' && (a.attributes.title = a.content.replace(/&amp;/, '&')) }), Object.defineProperty(Prism.languages.markup.tag, 'addInlined', { value: function (a, e) { var s = {}; s['language-' + e] = { pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i, lookbehind: !0, inside: Prism.languages[e] }, s.cdata = /^<!\[CDATA\[|\]\]>$/i; var n = { 'included-cdata': { pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i, inside: s } }; n['language-' + e] = { pattern: /[\s\S]+/, inside: Prism.languages[e] }; var t = {}; t[a] = { pattern: RegExp('(<__[\\s\\S]*?>)(?:<!\\[CDATA\\[[\\s\\S]*?\\]\\]>\\s*|[\\s\\S])*?(?=<\\/__>)'.replace(/__/g, function () { return a }), 'i'), lookbehind: !0, greedy: !0, inside: n }, Prism.languages.insertBefore('markup', 'cdata', t) } }), Prism.languages.xml = Prism.languages.extend('markup', {}), Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup
!(function (s) { var e = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/; s.languages.css = { comment: /\/\*[\s\S]*?\*\//, atrule: { pattern: /@[\w-]+[\s\S]*?(?:;|(?=\s*\{))/, inside: { rule: /^@[\w-]+/, 'selector-function-argument': { pattern: /(\bselector\s*\((?!\s*\))\s*)(?:[^()]|\((?:[^()]|\([^()]*\))*\))+?(?=\s*\))/, lookbehind: !0, alias: 'selector' } } }, url: { pattern: RegExp('url\\((?:' + e.source + '|[^\n\r()]*)\\)', 'i'), greedy: !0, inside: { function: /^url/i, punctuation: /^\(|\)$/ } }, selector: RegExp("[^{}\\s](?:[^{};\"']|" + e.source + ')*?(?=\\s*\\{)'), string: { pattern: e, greedy: !0 }, property: /[-_a-z\xA0-\uFFFF][-\w\xA0-\uFFFF]*(?=\s*:)/i, important: /!important\b/i, function: /[-a-z0-9]+(?=\()/i, punctuation: /[(){};:,]/ }, s.languages.css.atrule.inside.rest = s.languages.css; var t = s.languages.markup; t && (t.tag.addInlined('style', 'css'), s.languages.insertBefore('inside', 'attr-value', { 'style-attr': { pattern: /\s*style=("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/i, inside: { 'attr-name': { pattern: /^\s*style/i, inside: t.tag.inside }, punctuation: /^\s*=\s*['"]|['"]\s*$/, 'attr-value': { pattern: /.+/i, inside: s.languages.css } }, alias: 'language-css' } }, t.tag)) }(Prism))
Prism.languages.clike = { comment: [{ pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/, lookbehind: !0 }, { pattern: /(^|[^\\:])\/\/.*/, lookbehind: !0, greedy: !0 }], string: { pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, 'class-name': { pattern: /(\b(?:class|interface|extends|implements|trait|instanceof|new)\s+|\bcatch\s+\()[\w.\\]+/i, lookbehind: !0, inside: { punctuation: /[.\\]/ } }, keyword: /\b(?:if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/, boolean: /\b(?:true|false)\b/, function: /\w+(?=\()/, number: /\b0x[\da-f]+\b|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?/i, operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/, punctuation: /[{}[\];(),.:]/ }
Prism.languages.javascript = Prism.languages.extend('clike', { 'class-name': [Prism.languages.clike['class-name'], { pattern: /(^|[^$\w\xA0-\uFFFF])[_$A-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\.(?:prototype|constructor))/, lookbehind: !0 }], keyword: [{ pattern: /((?:^|})\s*)(?:catch|finally)\b/, lookbehind: !0 }, { pattern: /(^|[^.]|\.\.\.\s*)\b(?:as|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/, lookbehind: !0 }], number: /\b(?:(?:0[xX](?:[\dA-Fa-f](?:_[\dA-Fa-f])?)+|0[bB](?:[01](?:_[01])?)+|0[oO](?:[0-7](?:_[0-7])?)+)n?|(?:\d(?:_\d)?)+n|NaN|Infinity)\b|(?:\b(?:\d(?:_\d)?)+\.?(?:\d(?:_\d)?)*|\B\.(?:\d(?:_\d)?)+)(?:[Ee][+-]?(?:\d(?:_\d)?)+)?/, function: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/, operator: /--|\+\+|\*\*=?|=>|&&|\|\||[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?[.?]?|[~:]/ }), Prism.languages.javascript['class-name'][0].pattern = /(\b(?:class|interface|extends|implements|instanceof|new)\s+)[\w.\\]+/, Prism.languages.insertBefore('javascript', 'keyword', { regex: { pattern: /((?:^|[^$\w\xA0-\uFFFF."'\])\s])\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*]|\\.|[^/\\\[\r\n])+\/[gimyus]{0,6}(?=(?:\s|\/\*[\s\S]*?\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/, lookbehind: !0, greedy: !0 }, 'function-variable': { pattern: /#?[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)\s*=>))/, alias: 'function' }, parameter: [{ pattern: /(function(?:\s+[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*)?\s*\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\))/, lookbehind: !0, inside: Prism.languages.javascript }, { pattern: /[_$a-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*(?=\s*=>)/i, inside: Prism.languages.javascript }, { pattern: /(\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*=>)/, lookbehind: !0, inside: Prism.languages.javascript }, { pattern: /((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:[_$A-Za-z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\s*)\(\s*)(?!\s)(?:[^()]|\([^()]*\))+?(?=\s*\)\s*\{)/, lookbehind: !0, inside: Prism.languages.javascript }], constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/ }), Prism.languages.insertBefore('javascript', 'string', { 'template-string': { pattern: /`(?:\\[\s\S]|\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}|(?!\${)[^\\`])*`/, greedy: !0, inside: { 'template-punctuation': { pattern: /^`|`$/, alias: 'string' }, interpolation: { pattern: /((?:^|[^\\])(?:\\{2})*)\${(?:[^{}]|{(?:[^{}]|{[^}]*})*})+}/, lookbehind: !0, inside: { 'interpolation-punctuation': { pattern: /^\${|}$/, alias: 'punctuation' }, rest: Prism.languages.javascript } }, string: /[\s\S]+/ } } }), Prism.languages.markup && Prism.languages.markup.tag.addInlined('script', 'javascript'), Prism.languages.js = Prism.languages.javascript
Prism.languages.c = Prism.languages.extend('clike', { comment: { pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/, greedy: !0 }, 'class-name': { pattern: /(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+/, lookbehind: !0 }, keyword: /\b(?:__attribute__|_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/, function: /[a-z_]\w*(?=\s*\()/i, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/, number: /(?:\b0x(?:[\da-f]+\.?[\da-f]*|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+\.?\d*|\B\.\d+)(?:e[+-]?\d+)?)[ful]*/i }), Prism.languages.insertBefore('c', 'string', { macro: { pattern: /(^\s*)#\s*[a-z]+(?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im, lookbehind: !0, alias: 'property', inside: { string: { pattern: /(#\s*include\s*)(?:<.+?>|("|')(?:\\?.)+?\2)/, lookbehind: !0 }, directive: { pattern: /(#\s*)\b(?:define|defined|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/, lookbehind: !0, alias: 'keyword' } } }, constant: /\b(?:__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|stdin|stdout|stderr)\b/ }), delete Prism.languages.c.boolean
Prism.languages.cpp = Prism.languages.extend('c', { 'class-name': { pattern: /(\b(?:class|enum|struct)\s+)\w+/, lookbehind: !0 }, keyword: /\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char8_t|char16_t|char32_t|class|compl|concept|const|consteval|constexpr|constinit|const_cast|continue|co_await|co_return|co_yield|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|float|for|friend|goto|if|inline|int|int8_t|int16_t|int32_t|int64_t|uint8_t|uint16_t|uint32_t|uint64_t|long|mutable|namespace|new|noexcept|nullptr|operator|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/, number: { pattern: /(?:\b0b[01']+|\b0x(?:[\da-f']+\.?[\da-f']*|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+\.?[\d']*|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]*/i, greedy: !0 }, operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/, boolean: /\b(?:true|false)\b/ }), Prism.languages.insertBefore('cpp', 'string', { 'raw-string': { pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/, alias: 'string', greedy: !0 } })
!(function (h) { function v (e, n) { return '___' + e.toUpperCase() + n + '___' }Object.defineProperties(h.languages['markup-templating'] = {}, { buildPlaceholders: { value: function (a, r, e, o) { if (a.language === r) { var c = a.tokenStack = []; a.code = a.code.replace(e, function (e) { if (typeof o === 'function' && !o(e)) return e; for (var n, t = c.length; a.code.indexOf(n = v(r, t)) !== -1;)++t; return c[t] = e, n }), a.grammar = h.languages.markup } } }, tokenizePlaceholders: { value: function (p, k) { if (p.language === k && p.tokenStack) { p.grammar = h.languages[k]; var m = 0; var d = Object.keys(p.tokenStack); !(function e (n) { for (var t = 0; t < n.length && !(m >= d.length); t++) { var a = n[t]; if (typeof a === 'string' || a.content && typeof a.content === 'string') { var r = d[m]; var o = p.tokenStack[r]; var c = typeof a === 'string' ? a : a.content; var i = v(k, r); var u = c.indexOf(i); if (u > -1) { ++m; var g = c.substring(0, u); var l = new h.Token(k, h.tokenize(o, p.grammar), 'language-' + k, o); var s = c.substring(u + i.length); var f = []; g && f.push.apply(f, e([g])), f.push(l), s && f.push.apply(f, e([s])), typeof a === 'string' ? n.splice.apply(n, [t, 1].concat(f)) : a.content = f } } else a.content && e(a.content) } return n }(p.tokens)) } } } }) }(Prism))
!(function (e) { e.languages.django = { comment: /^{#[\s\S]*?#}$/, tag: { pattern: /(^{%[+-]?\s*)\w+/, lookbehind: !0, alias: 'keyword' }, delimiter: { pattern: /^{[{%][+-]?|[+-]?[}%]}$/, alias: 'punctuation' }, string: { pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/, greedy: !0 }, filter: { pattern: /(\|)\w+/, lookbehind: !0, alias: 'function' }, test: { pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/, lookbehind: !0, alias: 'function' }, function: /\b[a-z_]\w+(?=\s*\()/i, keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/, operator: /[-+*/%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, number: /\b\d+(?:\.\d+)?\b/, boolean: /[Tt]rue|[Ff]alse|[Nn]one/, variable: /\b\w+?\b/, punctuation: /[{}[\](),.:;]/ }; var n = /{{[\s\S]*?}}|{%[\s\S]*?%}|{#[\s\S]*?#}/g; var o = e.languages['markup-templating']; e.hooks.add('before-tokenize', function (e) { o.buildPlaceholders(e, 'django', n) }), e.hooks.add('after-tokenize', function (e) { o.tokenizePlaceholders(e, 'django') }), e.languages.jinja2 = e.languages.django, e.hooks.add('before-tokenize', function (e) { o.buildPlaceholders(e, 'jinja2', n) }), e.hooks.add('after-tokenize', function (e) { o.tokenizePlaceholders(e, 'jinja2') }) }(Prism))
Prism.languages.git = { comment: /^#.*/m, deleted: /^[-â€“].*/m, inserted: /^\+.*/m, string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/m, command: { pattern: /^.*\$ git .*$/m, inside: { parameter: /\s--?\w+/m } }, coord: /^@@.*@@$/m, commit_sha1: /^commit \w{40}$/m }
Prism.languages.go = Prism.languages.extend('clike', { keyword: /\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/, builtin: /\b(?:bool|byte|complex(?:64|128)|error|float(?:32|64)|rune|string|u?int(?:8|16|32|64)?|uintptr|append|cap|close|complex|copy|delete|imag|len|make|new|panic|print(?:ln)?|real|recover)\b/, boolean: /\b(?:_|iota|nil|true|false)\b/, operator: /[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./, number: /(?:\b0x[a-f\d]+|(?:\b\d+\.?\d*|\B\.\d+)(?:e[-+]?\d+)?)i?/i, string: { pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/, greedy: !0 } }), delete Prism.languages.go['class-name']
!(function (e) { var t = /\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|null|open|opens|package|private|protected|provides|public|record|requires|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/; var a = /\b[A-Z](?:\w*[a-z]\w*)?\b/; e.languages.java = e.languages.extend('clike', { 'class-name': [a, /\b[A-Z]\w*(?=\s+\w+\s*[;,=())])/], keyword: t, function: [e.languages.clike.function, { pattern: /(\:\:)[a-z_]\w*/, lookbehind: !0 }], number: /\b0b[01][01_]*L?\b|\b0x[\da-f_]*\.?[\da-f_p+-]+\b|(?:\b\d[\d_]*\.?[\d_]*|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i, operator: { pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m, lookbehind: !0 } }), e.languages.insertBefore('java', 'string', { 'triple-quoted-string': { pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/, greedy: !0, alias: 'string' } }), e.languages.insertBefore('java', 'class-name', { annotation: { alias: 'punctuation', pattern: /(^|[^.])@\w+/, lookbehind: !0 }, namespace: { pattern: /(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)[a-z]\w*(?:\.[a-z]\w*)+/, lookbehind: !0, inside: { punctuation: /\./ } }, generics: { pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/, inside: { 'class-name': a, keyword: t, punctuation: /[<>(),.:]/, operator: /[?&|]/ } } }) }(Prism))
!(function (e) { var n = '\\\\\\((?:[^()]|\\([^()]*\\))*\\)'; var t = RegExp('"(?:[^"\r\n\\\\]|\\\\[^\r\n(]|__)*"'.replace(/__/g, function () { return n })); var i = { interpolation: { pattern: RegExp('((?:^|[^\\\\])(?:\\\\{2})*)' + n), lookbehind: !0, inside: { content: { pattern: /^(\\\()[\s\S]+(?=\)$)/, lookbehind: !0, inside: null }, punctuation: /^\\\(|\)$/ } } }; var a = e.languages.jq = { comment: /#.*/, property: { pattern: RegExp(t.source + '(?=\\s*:(?!:))'), greedy: !0, inside: i }, string: { pattern: t, greedy: !0, inside: i }, function: { pattern: /(\bdef\s+)[a-z_]\w+/i, lookbehind: !0 }, variable: /\B\$\w+/, 'property-literal': { pattern: /[a-z_]\w*(?=\s*:(?!:))/i, alias: 'property' }, keyword: /\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/, boolean: /\b(?:true|false)\b/, number: /(?:\b\d+\.|\B\.)?\d+(?:[eE][+-]?\d+)?\b/, operator: [{ pattern: /\|=?/, alias: 'pipe' }, /\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|or|not)\b/], 'c-style-function': { pattern: /\b[a-z_]\w*(?=\s*\()/i, alias: 'function' }, punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/, dot: { pattern: /\./, alias: 'important' } }; i.interpolation.inside.content.inside = a }(Prism))
Prism.languages.json = { property: { pattern: /"(?:\\.|[^\\"\r\n])*"(?=\s*:)/, greedy: !0 }, string: { pattern: /"(?:\\.|[^\\"\r\n])*"(?!\s*:)/, greedy: !0 }, comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/, number: /-?\d+\.?\d*(?:e[+-]?\d+)?/i, punctuation: /[{}[\],]/, operator: /:/, boolean: /\b(?:true|false)\b/, null: { pattern: /\bnull\b/, alias: 'keyword' } }
!(function (d) { function n (n, e) { return n = n.replace(/<inner>/g, function () { return '(?:\\\\.|[^\\\\\n\r]|(?:\n|\r\n?)(?!\n|\r\n?))' }), e && (n = n + '|' + n.replace(/_/g, '\\*')), RegExp('((?:^|[^\\\\])(?:\\\\{2})*)(?:' + n + ')') } var e = '(?:\\\\.|``.+?``|`[^`\r\n]+`|[^\\\\|\r\n`])+'; var t = '\\|?__(?:\\|__)+\\|?(?:(?:\n|\r\n?)|$)'.replace(/__/g, function () { return e }); var a = '\\|?[ \t]*:?-{3,}:?[ \t]*(?:\\|[ \t]*:?-{3,}:?[ \t]*)+\\|?(?:\n|\r\n?)'; d.languages.markdown = d.languages.extend('markup', {}), d.languages.insertBefore('markdown', 'prolog', { blockquote: { pattern: /^>(?:[\t ]*>)*/m, alias: 'punctuation' }, table: { pattern: RegExp('^' + t + a + '(?:' + t + ')*', 'm'), inside: { 'table-data-rows': { pattern: RegExp('^(' + t + a + ')(?:' + t + ')*$'), lookbehind: !0, inside: { 'table-data': { pattern: RegExp(e), inside: d.languages.markdown }, punctuation: /\|/ } }, 'table-line': { pattern: RegExp('^(' + t + ')' + a + '$'), lookbehind: !0, inside: { punctuation: /\||:?-{3,}:?/ } }, 'table-header-row': { pattern: RegExp('^' + t + '$'), inside: { 'table-header': { pattern: RegExp(e), alias: 'important', inside: d.languages.markdown }, punctuation: /\|/ } } } }, code: [{ pattern: /((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/, lookbehind: !0, alias: 'keyword' }, { pattern: /``.+?``|`[^`\r\n]+`/, alias: 'keyword' }, { pattern: /^```[\s\S]*?^```$/m, greedy: !0, inside: { 'code-block': { pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m, lookbehind: !0 }, 'code-language': { pattern: /^(```).+/, lookbehind: !0 }, punctuation: /```/ } }], title: [{ pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m, alias: 'important', inside: { punctuation: /==+$|--+$/ } }, { pattern: /(^\s*)#+.+/m, lookbehind: !0, alias: 'important', inside: { punctuation: /^#+|#+$/ } }], hr: { pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m, lookbehind: !0, alias: 'punctuation' }, list: { pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m, lookbehind: !0, alias: 'punctuation' }, 'url-reference': { pattern: /!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/, inside: { variable: { pattern: /^(!?\[)[^\]]+/, lookbehind: !0 }, string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/, punctuation: /^[\[\]!:]|[<>]/ }, alias: 'url' }, bold: { pattern: n('__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__', !0), lookbehind: !0, greedy: !0, inside: { content: { pattern: /(^..)[\s\S]+(?=..$)/, lookbehind: !0, inside: {} }, punctuation: /\*\*|__/ } }, italic: { pattern: n('_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_', !0), lookbehind: !0, greedy: !0, inside: { content: { pattern: /(^.)[\s\S]+(?=.$)/, lookbehind: !0, inside: {} }, punctuation: /[*_]/ } }, strike: { pattern: n('(~~?)(?:(?!~)<inner>)+?\\2', !1), lookbehind: !0, greedy: !0, inside: { content: { pattern: /(^~~?)[\s\S]+(?=\1$)/, lookbehind: !0, inside: {} }, punctuation: /~~?/ } }, url: { pattern: n('!?\\[(?:(?!\\])<inner>)+\\](?:\\([^\\s)]+(?:[\t ]+"(?:\\\\.|[^"\\\\])*")?\\)| ?\\[(?:(?!\\])<inner>)+\\])', !1), lookbehind: !0, greedy: !0, inside: { variable: { pattern: /(\[)[^\]]+(?=\]$)/, lookbehind: !0 }, content: { pattern: /(^!?\[)[^\]]+(?=\])/, lookbehind: !0, inside: {} }, string: { pattern: /"(?:\\.|[^"\\])*"(?=\)$)/ } } } }), ['url', 'bold', 'italic', 'strike'].forEach(function (e) { ['url', 'bold', 'italic', 'strike'].forEach(function (n) { e !== n && (d.languages.markdown[e].inside.content.inside[n] = d.languages.markdown[n]) }) }), d.hooks.add('after-tokenize', function (n) { n.language !== 'markdown' && n.language !== 'md' || !(function n (e) { if (e && typeof e !== 'string') for (var t = 0, a = e.length; t < a; t++) { var i = e[t]; if (i.type === 'code') { var r = i.content[1]; var o = i.content[3]; if (r && o && r.type === 'code-language' && o.type === 'code-block' && typeof r.content === 'string') { var l = r.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp'); var s = 'language-' + (l = (/[a-z][\w-]*/i.exec(l) || [''])[0].toLowerCase()); o.alias ? typeof o.alias === 'string' ? o.alias = [o.alias, s] : o.alias.push(s) : o.alias = [s] } } else n(i.content) } }(n.tokens)) }), d.hooks.add('wrap', function (n) { if (n.type === 'code-block') { for (var e = '', t = 0, a = n.classes.length; t < a; t++) { var i = n.classes[t]; var r = /language-(.+)/.exec(i); if (r) { e = r[1]; break } } var o = d.languages[e]; if (o) { var l = n.content.replace(/&lt;/g, '<').replace(/&amp;/g, '&'); n.content = d.highlight(l, o, e) } else if (e && e !== 'none' && d.plugins.autoloader) { var s = 'md-' + (new Date()).valueOf() + '-' + Math.floor(1e16 * Math.random()); n.attributes.id = s, d.plugins.autoloader.loadLanguages(e, function () { var n = document.getElementById(s); n && (n.innerHTML = d.highlight(n.textContent, d.languages[e], e)) }) } } }), d.languages.md = d.languages.markdown }(Prism))
Prism.languages.python = { comment: { pattern: /(^|[^\\])#.*/, lookbehind: !0 }, 'string-interpolation': { pattern: /(?:f|rf|fr)(?:("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i, greedy: !0, inside: { interpolation: { pattern: /((?:^|[^{])(?:{{)*){(?!{)(?:[^{}]|{(?!{)(?:[^{}]|{(?!{)(?:[^{}])+})+})+}/, lookbehind: !0, inside: { 'format-spec': { pattern: /(:)[^:(){}]+(?=}$)/, lookbehind: !0 }, 'conversion-option': { pattern: /![sra](?=[:}]$)/, alias: 'punctuation' }, rest: null } }, string: /[\s\S]+/ } }, 'triple-quoted-string': { pattern: /(?:[rub]|rb|br)?("""|''')[\s\S]+?\1/i, greedy: !0, alias: 'string' }, string: { pattern: /(?:[rub]|rb|br)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i, greedy: !0 }, function: { pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g, lookbehind: !0 }, 'class-name': { pattern: /(\bclass\s+)\w+/i, lookbehind: !0 }, decorator: { pattern: /(^\s*)@\w+(?:\.\w+)*/im, lookbehind: !0, alias: ['annotation', 'punctuation'], inside: { punctuation: /\./ } }, keyword: /\b(?:and|as|assert|async|await|break|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/, builtin: /\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/, boolean: /\b(?:True|False|None)\b/, number: /(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*\.?\d*|\.\d+)(?:e[+-]?\d+)?j?\b/i, operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/, punctuation: /[{}[\];(),.:]/ }, Prism.languages.python['string-interpolation'].inside.interpolation.inside.rest = Prism.languages.python, Prism.languages.py = Prism.languages.python
